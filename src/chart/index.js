import React, {useEffect, useRef, useState} from 'react';
import Chart from 'chart.js'
import _ from 'underscore';

export function DDChart(props) {

  const [chartApi, setChartApi] = useState(null);

  const ctx = useRef(null);

  const destroyApi = () => {
    if (chartApi) {
      chartApi.destroy();
    }
  }

  const getLabels = (data, labelKey) => {
    if (typeof props.getLabels === 'function') {
      return props.getLabels(data)
    } else if (Array.isArray(props.getLabels)) {
      return props.getLabels;
    }
    let groupedData = _.groupBy(data, labelKey);
    return Object.keys(groupedData);
  }

  /**
   * if the input value is an array compute the output with props.accumulator if its defined.
   * @param value
   * @returns {*} cumulated value.
   * if the value is not an array and props.accumulator is not defined then input value is returned.
   */
  const accumulator = (value) => {
    if (typeof props.accumulator === 'function') {
      return props.accumulator(value)
    }
    if (Array.isArray(value)) {
      return value.length
    }
    return value;
  }

  /**
   * group by labelKey input data and output an array of accumulated value.
   * @param data
   * @param labelKey
   * @param labels
   * @returns {unknown[]|*}
   */
  const getData = (data, labelKey, labels) => {
    if (typeof props.getData === 'function') {
      return props.getData(data, labelKey)
    } else if (Array.isArray(props.getData)) {
      return props.getData;
    }
    let groupedData = _.groupBy(data, labelKey);
    if (labels) {
      return labels.map(label => {
        let labelValue = groupedData[label] || [];
        return accumulator(labelValue);
      });
    }
    return Object.values(groupedData).map(accumulator);
  }

  /**
   * Generate random colors for chart.
   * if props.getLabelColor is defined it is called.
   * If dataGroupKey is defined generate only one color for all labels
   * @param labels
   * @param dataGroupKey
   * @returns {*}
   */
  const getLabelColor = (labels, dataGroupKey) => {
    if (typeof props.getLabelColor === 'function') {
      return props.getLabelColor(labels, dataGroupKey)
    } else if (Array.isArray(props.getLabelColor)) {
      return props.getLabelColor;
    }
    if(dataGroupKey) {
      let color = {
        r: Math.ceil(Math.random() * 255),
        g: Math.ceil(Math.random() * 255),
        b: Math.ceil(Math.random() * 255),
        a: 0.2
      };
      return labels.map(label => color);
    }
    return labels.map(label => {
      return {
        r: Math.ceil(Math.random() * 255),
        g: Math.ceil(Math.random() * 255),
        b: Math.ceil(Math.random() * 255),
        a: 0.2
      };
    });
  }

  /**
   * Based on color generated by getLabelColor
   * @param labelColor
   * @returns {*}
   */
  const getBackgroundColor = (labelColor) => {
    return labelColor ? labelColor.map(color => {
      color.a = props.backgroundOpacity || 0.2;
      return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
    }) : labelColor;
  }

  /**
   * Based on color generated by getLabelColor set border opacity
   * @param labelColor
   * @returns {*}
   */
  const getBorderColor = (labelColor) => {
    return labelColor ? labelColor.map(color => {
      color.a = props.borderOpacity || 1;
      return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
    }) : labelColor;
  }

  const initChart = () => {
    let options = Object.assign({
      scales: {
        yAxes: [{
          ticks: {
            beginAtZero: true
          }
        }]
      }
    }, props.options || {});

    let labelKey = Array.isArray(props.labelKey) ? props.labelKey : [props.labelKey];
    let initialData = props.data;
    let labelKeyValue = labelKey[0];
    let labels = getLabels(initialData, labelKeyValue); // ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange']
    let datasets = [];

    let getDataset = (dataGroup, dataGroupKey, labelColor) => {
      let data = getData(dataGroup, labelKeyValue, labels); // [12, 19, 3, 5, 2, 3]
      let backgroundColor = getBackgroundColor(labelColor);
      let borderColor = getBorderColor(labelColor);
      let dataset = {
        label: `${labelKey[1] && typeof labelKey[1] === 'string' ? (labelKey[1] + ' / ') : ''}${typeof dataGroupKey === 'string' ? dataGroupKey : '#'}`,
        data: data,
        borderWidth: props.borderWidth || 1
      };
      if (backgroundColor) {
        dataset.backgroundColor = backgroundColor;
      }
      if (borderColor) {
        dataset.borderColor = borderColor;
      }
      return dataset;
    }

    if (labelKey.length === 1) {
      let labelColor = getLabelColor(labels);
      let dataset = getDataset(initialData, labelKeyValue, labelColor);
      datasets.push(dataset);
    } else {
      let groupName = labelKey[1];
      let dataByGroupName = _.groupBy(initialData, groupName);
      let groupLabels = Object.keys(dataByGroupName);
      datasets = groupLabels.map(dataGroupKey => {
        let labelColor = getLabelColor(labels, dataGroupKey);
        return getDataset(dataByGroupName[dataGroupKey], dataGroupKey, labelColor);
      });
    }
    console.log('--- datasets --- ', datasets);
    const chart = new Chart(ctx.current, {
      type: props.type || 'bar',
      data: {
        labels: labels,
        datasets: datasets
      },
      options: options
    });
    setChartApi(chart);
    return destroyApi;
  }

  useEffect(initChart, [props.data]);

  return <canvas ref={ctx} height={props.height} width={props.width}/>
}
